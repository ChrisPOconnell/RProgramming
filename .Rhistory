files_full <- list.files(path = directory, full.names=TRUE)
#Experimenting
#dat <- data.frame()
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)   #Get end position for while loop
readings <- data.frame()
sub_readings <- data.frame()
temp_data <- data.frame()
while(i < length(id)) {
i <-  i + 1
#The following line introduced major errors during the RBIND function if the [,pollutant] was not commented out.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
#temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)[,pollutant]
readings <- rbind(read.csv(file = files_full[id[i]], header = TRUE,sep = "")[,pollutant],readings)
#print(temp_dat)
#readings <- rbind(readings,temp_dat)
dim(readings)
print(readings)
}
sub_readings <- readings#[,pollutant]    #This line subsets the data based on polutant type...
mean(sub_readings,na.rm = TRUE)
}
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#This isn't perfect because it needs to read the variable 'directory'.  Can't figure out how to make it do that CO
#the results of this code block is a list of file names!  Perfect!
#files_full <- list.files(path = "C:/Users/chris_000/Documents/GitHub/specdata/", full.names=TRUE)
files_full <- list.files(path = directory, full.names=TRUE)
#Experimenting
#dat <- data.frame()
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)   #Get end position for while loop
readings <- data.frame()
sub_readings <- data.frame()
temp_data <- data.frame()
while(i < length(id)) {
i <-  i + 1
#The following line introduced major errors during the RBIND function if the [,pollutant] was not commented out.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
#temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)[,pollutant]
readings <- rbind(read.csv(file = files_full[id[i]], header = TRUE,sep = "")[,pollutant],readings)
#print(temp_dat)
#readings <- rbind(readings,temp_dat)
dim(readings)
print(readings)
}
sub_readings <- readings#[,pollutant]    #This line subsets the data based on polutant type...
mean(sub_readings,na.rm = TRUE)
}
pollutantmean("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#This isn't perfect because it needs to read the variable 'directory'.  Can't figure out how to make it do that CO
#the results of this code block is a list of file names!  Perfect!
#files_full <- list.files(path = "C:/Users/chris_000/Documents/GitHub/specdata/", full.names=TRUE)
files_full <- list.files(path = directory, full.names=TRUE)
#Experimenting
#dat <- data.frame()
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)   #Get end position for while loop
readings <- data.frame()
sub_readings <- data.frame()
temp_data <- data.frame()
while(i < length(id)) {
i <-  i + 1
#The following line introduced major errors during the RBIND function if the [,pollutant] was not commented out.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
#temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)[,pollutant]
readings <- rbind(read.csv(file = files_full[id[i]], header = TRUE)[,pollutant],readings)
#print(temp_dat)
#readings <- rbind(readings,temp_dat)
dim(readings)
print(readings)
}
sub_readings <- readings#[,pollutant]    #This line subsets the data based on polutant type...
mean(sub_readings,na.rm = TRUE)
}
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#This isn't perfect because it needs to read the variable 'directory'.  Can't figure out how to make it do that CO
#the results of this code block is a list of file names!  Perfect!
#files_full <- list.files(path = "C:/Users/chris_000/Documents/GitHub/specdata/", full.names=TRUE)
files_full <- list.files(path = directory, full.names=TRUE)
#Experimenting
#dat <- data.frame()
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)   #Get end position for while loop
readings <- data.frame()
sub_readings <- data.frame()
temp_data <- data.frame()
while(i < length(id)) {
i <-  i + 1
#The following line introduced major errors during the RBIND function if the [,pollutant] was not commented out.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
#temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)[,pollutant]
readings <- rbind(read.csv(file = files_full[id[i]], header = TRUE)[,pollutant],readings)
#print(temp_dat)
#readings <- rbind(readings,temp_dat)
dim(readings)
print(readings)
}
sub_readings <- readings#[,pollutant]    #This line subsets the data based on polutant type...
mean(sub_readings,na.rm = TRUE)
}
pollutantmean("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
complete <- function(directory, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
files_full <- list.files(path = directory, full.names=TRUE)
file_total <- sum(files_full)
## Return a data frame of the form:
## id nobs
## 1  117
## 2  1041
## ...
## where 'id' is the monitor ID number and 'nobs' is the
## number of complete cases
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
complete <- function(directory, id = 1:332) {
#SAMPLE COMMAND
#complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
files_full <- list.files(path = directory, full.names=TRUE)
file_total <- length(files_full)
## Return a data frame of the form:
## id nobs
## 1  117
## 2  1041
## ...
## where 'id' is the monitor ID number and 'nobs' is the
## number of complete cases
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
complete <- function(directory, id = 1:332) {
#SAMPLE COMMAND
#complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
files_full <- list.files(path = directory, full.names=TRUE)
file_total <- length(files_full)
print("File total: ",file_total)
## Return a data frame of the form:
## id nobs
## 1  117
## 2  1041
## ...
## where 'id' is the monitor ID number and 'nobs' is the
## number of complete cases
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
?print
complete <- function(directory, id = 1:332) {
#SAMPLE COMMAND
#complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
files_full <- list.files(path = directory, full.names=TRUE)
file_total <- length(files_full)
"file totals: " print(file_total)
## Return a data frame of the form:
## id nobs
## 1  117
## 2  1041
## ...
## where 'id' is the monitor ID number and 'nobs' is the
## number of complete cases
}
complete <- function(directory, id = 1:332) {
#SAMPLE COMMAND
#complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
files_full <- list.files(path = directory, full.names=TRUE)
file_total <- length(files_full)
"file totals: "
print(file_total)
## Return a data frame of the form:
## id nobs
## 1  117
## 2  1041
## ...
## where 'id' is the monitor ID number and 'nobs' is the
## number of complete cases
}
complete <- function(directory, id = 1:332) {
#SAMPLE COMMAND
#complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
files_full <- list.files(path = directory, full.names=TRUE)
file_total <- length(files_full)
"file totals: "
print(file_total)
## Return a data frame of the form:
## id nobs
## 1  117
## 2  1041
## ...
## where 'id' is the monitor ID number and 'nobs' is the
## number of complete cases
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
complete <- function(directory, id = 1:332) {
#SAMPLE COMMAND
#complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
files_full <- list.files(path = directory, full.names=TRUE)
file_total <- length(files_full)
print("file totals: " )
print(file_total)
## Return a data frame of the form:
## id nobs
## 1  117
## 2  1041
## ...
## where 'id' is the monitor ID number and 'nobs' is the
## number of complete cases
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
?data.frame
pollutantmean <- function(directory, pollutant, id = 1:332) {
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#Pulls a list of files into files_full.  Will later be referenced by counter i in while loop.
files_full <- list.files(path = directory, full.names=TRUE) #by the way, this is sloppy code
#Only because the files are in sequential order does this work.
#what would happen if someone removed file 002?
#reference pointers to files_ful[id[2]] would actually equal file 003.
#String manipulation with if/else would be better.
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)  #Originally this was goin to be used in while loop, while(i < x).  Found out
#length(id) would work, so no need for an additional variable.
readings <- data.frame(id,nobs)  #the readings from our observation files.
print(dim(readings))
while(i < length(id)) {
i <-  i + 1
#The following [,pollutant] filter introduced major errors during the RBIND function.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)#[,pollutant]
readings <- rbind(readings,temp_dat)
}
sub_readings <- readings[,pollutant]    #This line subsets the data based on polutant type...
#Less processing and memory would be required if this filter
#could be applied during read.csv.
mean(sub_readings,na.rm = TRUE)         #I'm not super pleased with the way this turned out either.  I would like
#to find another way to get these na values out.
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
pollutantmean <- function(directory, pollutant, id = 1:332) {
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#Pulls a list of files into files_full.  Will later be referenced by counter i in while loop.
files_full <- list.files(path = directory, full.names=TRUE) #by the way, this is sloppy code
#Only because the files are in sequential order does this work.
#what would happen if someone removed file 002?
#reference pointers to files_ful[id[2]] would actually equal file 003.
#String manipulation with if/else would be better.
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)  #Originally this was goin to be used in while loop, while(i < x).  Found out
#length(id) would work, so no need for an additional variable.
readings <- data.frame(id,nobs)  #the readings from our observation files.
print(readings)
while(i < length(id)) {
i <-  i + 1
#The following [,pollutant] filter introduced major errors during the RBIND function.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)#[,pollutant]
readings <- rbind(readings,temp_dat)
}
sub_readings <- readings[,pollutant]    #This line subsets the data based on polutant type...
#Less processing and memory would be required if this filter
#could be applied during read.csv.
mean(sub_readings,na.rm = TRUE)         #I'm not super pleased with the way this turned out either.  I would like
#to find another way to get these na values out.
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
pollutantmean <- function(directory, pollutant, id = 1:332) {
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#Pulls a list of files into files_full.  Will later be referenced by counter i in while loop.
files_full <- list.files(path = directory, full.names=TRUE) #by the way, this is sloppy code
#Only because the files are in sequential order does this work.
#what would happen if someone removed file 002?
#reference pointers to files_ful[id[2]] would actually equal file 003.
#String manipulation with if/else would be better.
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)  #Originally this was goin to be used in while loop, while(i < x).  Found out
#length(id) would work, so no need for an additional variable.
readings <- data.frame(id,nobs)  #the readings from our observation files.
print(readings)
while(i < length(id)) {
i <-  i + 1
#The following [,pollutant] filter introduced major errors during the RBIND function.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)#[,pollutant]
readings <- rbind(readings,temp_dat)
}
sub_readings <- readings[,pollutant]    #This line subsets the data based on polutant type...
#Less processing and memory would be required if this filter
#could be applied during read.csv.
mean(sub_readings,na.rm = TRUE)         #I'm not super pleased with the way this turned out either.  I would like
#to find another way to get these na values out.
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
pollutantmean <- function(directory, pollutant, id = 1:332) {
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#Pulls a list of files into files_full.  Will later be referenced by counter i in while loop.
files_full <- list.files(path = directory, full.names=TRUE) #by the way, this is sloppy code
#Only because the files are in sequential order does this work.
#what would happen if someone removed file 002?
#reference pointers to files_ful[id[2]] would actually equal file 003.
#String manipulation with if/else would be better.
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)  #Originally this was goin to be used in while loop, while(i < x).  Found out
#length(id) would work, so no need for an additional variable.
readings <- data.frame(id,nobs)  #the readings from our observation files.
print(readings)
while(i < length(id)) {
i <-  i + 1
#The following [,pollutant] filter introduced major errors during the RBIND function.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)#[,pollutant]
readings <- rbind(readings,temp_dat)
}
sub_readings <- readings[,pollutant]    #This line subsets the data based on polutant type...
#Less processing and memory would be required if this filter
#could be applied during read.csv.
mean(sub_readings,na.rm = TRUE)         #I'm not super pleased with the way this turned out either.  I would like
#to find another way to get these na values out.
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
pollutantmean <- function(directory, pollutant, id = 1:332) {
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#Pulls a list of files into files_full.  Will later be referenced by counter i in while loop.
files_full <- list.files(path = directory, full.names=TRUE) #by the way, this is sloppy code
#Only because the files are in sequential order does this work.
#what would happen if someone removed file 002?
#reference pointers to files_ful[id[2]] would actually equal file 003.
#String manipulation with if/else would be better.
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)  #Originally this was goin to be used in while loop, while(i < x).  Found out
#length(id) would work, so no need for an additional variable.
readings <- data.frame(id,nobs)  #the readings from our observation files.
print(readings)
while(i < length(id)) {
i <-  i + 1
#The following [,pollutant] filter introduced major errors during the RBIND function.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)#[,pollutant]
readings <- rbind(readings,temp_dat)
}
sub_readings <- readings[,pollutant]    #This line subsets the data based on polutant type...
#Less processing and memory would be required if this filter
#could be applied during read.csv.
mean(sub_readings,na.rm = TRUE)         #I'm not super pleased with the way this turned out either.  I would like
#to find another way to get these na values out.
}
pollutantmean("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
pollutantmean("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
#Not sure what happened to this upload :(
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"
directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"
## 'pollutant' is a character vector of length 1 indicating
## the name of the pollutant for which we will calculate the
## mean; either "sulfate" or "nitrate".
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
## Return the mean of the pollutant across all monitors list
## in the 'id' vector (ignoring NA values)
## NOTE: Do not round the result!
#Debug, what class is id?
class(pollutantmean[id])
pollutantmean(id)
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
x <- length(id)   #Get end position for while loop
while(i < x) {
i <- i + 1        #Increase index counter
#printed_id <- print(id[i])   #This code works, prints each ID individually.
class(id)                  #This is not returning anything.
#   if(id[i] < 10) {
#      "ID IS LESS THAN 10!"
#    }
}
}
pollutantmean("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
pollutantmean <- function(directory, pollutant, id = 1:332) {
#SAMPLE COMMAND
#pollutantmean("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#Pulls a list of files into files_full.  Will later be referenced by counter i in while loop.
files_full <- list.files(path = directory, full.names=TRUE) #by the way, this is sloppy code
#Only because the files are in sequential order does this work.
#what would happen if someone removed file 002?
#reference pointers to files_ful[id[2]] would actually equal file 003.
#String manipulation with if/else would be better.
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)  #Originally this was goin to be used in while loop, while(i < x).  Found out
#length(id) would work, so no need for an additional variable.
readings <- data.frame()  #the readings from our observation files.
print(readings)
while(i < length(id)) {
i <-  i + 1
#The following [,pollutant] filter introduced major errors during the RBIND function.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)#[,pollutant]
readings <- rbind(readings,temp_dat)
}
sub_readings <- readings[,pollutant]    #This line subsets the data based on polutant type...
#Less processing and memory would be required if this filter
#could be applied during read.csv.
mean(sub_readings,na.rm = TRUE)         #I'm not super pleased with the way this turned out either.  I would like
#to find another way to get these na values out.
}
pollutantmean("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
pollutantmean <- function(directory, pollutant, id = 1:332) {
#SAMPLE COMMAND
#pollutantmean("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
#directory <- "C:/Users/ChrisP/Documents/GitHub/specdata"       #SURFACE PRO 3
#directory <-  "C:/Users/chris_000/Documents/GitHub/specdata/"  #e6430
#Pulls a list of files into files_full.  Will later be referenced by counter i in while loop.
files_full <- list.files(path = directory, full.names=TRUE) #by the way, this is sloppy code
#Only because the files are in sequential order does this work.
#what would happen if someone removed file 002?
#reference pointers to files_ful[id[2]] would actually equal file 003.
#String manipulation with if/else would be better.
#Code to set up While loop counters/variables.
i <- 0            #Set counter position
#x <- length(id)  #Originally this was goin to be used in while loop, while(i < x).  Found out
#length(id) would work, so no need for an additional variable.
readings <- data.frame()  #the readings from our observation files.
print(readings)
while(i < length(id)) {
i <-  i + 1
#The following [,pollutant] filter introduced major errors during the RBIND function.
#I had hoped originally to only import the pollutant column in order to save memory and increase processing speed.
temp_dat <- read.csv(file = files_full[id[i]], header = TRUE)#[,pollutant]
readings <- rbind(readings,temp_dat)
}
sub_readings <- readings[,pollutant]    #This line subsets the data based on polutant type...
#Less processing and memory would be required if this filter
#could be applied during read.csv.
mean(sub_readings,na.rm = TRUE)         #I'm not super pleased with the way this turned out either.  I would like
#to find another way to get these na values out.
}
pollutantmean("C:/Users/chris_000/Documents/GitHub/specdata/","nitrate",70:72)
complete <- function(directory, id = 1:332) {
#SAMPLE COMMAND
#complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
files_full <- list.files(path = directory, full.names=TRUE)
file_total <- length(files_full)
print("total files: " )
print(file_total)
readings <- data.frame(id,nobs)  #the readings from our observation files.
print(readings)
## Return a data frame of the form:
## id nobs
## 1  117
## 2  1041
## ...
## where 'id' is the monitor ID number and 'nobs' is the
## number of complete cases
}
complete("C:/Users/chris_000/Documents/GitHub/specdata/",)
q
